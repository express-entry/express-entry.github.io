function I(e){return Array.isArray(e)?e:[e]}const G={STOP:"STOP"};function M(e,t){const n=t(e);e.children!==void 0&&n!==G.STOP&&e.children.forEach(i=>M(i,t))}function F(e,t={}){const{preserveGroup:n=!1}=t,i=[],s=n?r=>{r.isLeaf||(i.push(r.key),u(r.children))}:r=>{r.isLeaf||(r.isGroup||i.push(r.key),u(r.children))};function u(r){r.forEach(s)}return u(e),i}function R(e,t){const{isLeaf:n}=e;return n!==void 0?n:!t(e)}function j(e){return e.children}function U(e){return e.key}function q(){return!1}function V(e,t){const{isLeaf:n}=e;return!(n===!1&&!Array.isArray(t(e)))}function W(e){return e.disabled===!0}function Z(e,t){return e.isLeaf===!1&&!Array.isArray(t(e))}function P(e){var t;return e==null?[]:Array.isArray(e)?e:(t=e.checkedKeys)!==null&&t!==void 0?t:[]}function x(e){var t;return e==null||Array.isArray(e)?[]:(t=e.indeterminateKeys)!==null&&t!==void 0?t:[]}function z(e,t){const n=new Set(e);return t.forEach(i=>{n.has(i)||n.add(i)}),Array.from(n)}function B(e,t){const n=new Set(e);return t.forEach(i=>{n.has(i)&&n.delete(i)}),Array.from(n)}function H(e){return(e==null?void 0:e.type)==="group"}class J extends Error{constructor(){super(),this.message="SubtreeNotLoadedError: checking a subtree whose required nodes are not fully loaded."}}function Q(e,t,n,i){return w(t.concat(e),n,i,!1)}function X(e,t){const n=new Set;return e.forEach(i=>{const s=t.treeNodeMap.get(i);if(s!==void 0){let u=s.parent;for(;u!==null&&!(u.disabled||n.has(u.key));)n.add(u.key),u=u.parent}}),n}function Y(e,t,n,i){const s=w(t,n,i,!1),u=w(e,n,i,!0),r=X(e,n),d=[];return s.forEach(f=>{(u.has(f)||r.has(f))&&d.push(f)}),d.forEach(f=>s.delete(f)),s}function E(e,t){const{checkedKeys:n,keysToCheck:i,keysToUncheck:s,indeterminateKeys:u,cascade:r,leafOnly:d,checkStrategy:f,allowNotLoaded:o}=e;if(!r)return i!==void 0?{checkedKeys:z(n,i),indeterminateKeys:Array.from(u)}:s!==void 0?{checkedKeys:B(n,s),indeterminateKeys:Array.from(u)}:{checkedKeys:Array.from(n),indeterminateKeys:Array.from(u)};const{levelTreeNodeMap:h}=t;let c;s!==void 0?c=Y(s,n,t,o):i!==void 0?c=Q(i,n,t,o):c=w(n,t,o,!1);const v=f==="parent",N=f==="child"||d,g=c,A=new Set,C=Math.max.apply(null,Array.from(h.keys()));for(let b=C;b>=0;b-=1){const L=b===0,S=h.get(b);for(const a of S){if(a.isLeaf)continue;const{key:l,shallowLoaded:p}=a;if(N&&p&&a.children.forEach(y=>{!y.disabled&&!y.isLeaf&&y.shallowLoaded&&g.has(y.key)&&g.delete(y.key)}),a.disabled||!p)continue;let K=!0,k=!1,m=!0;for(const y of a.children){const O=y.key;if(!y.disabled){if(m&&(m=!1),g.has(O))k=!0;else if(A.has(O)){k=!0,K=!1;break}else if(K=!1,k)break}}K&&!m?(v&&a.children.forEach(y=>{!y.disabled&&g.has(y.key)&&g.delete(y.key)}),g.add(l)):k&&A.add(l),L&&N&&g.has(l)&&g.delete(l)}}return{checkedKeys:Array.from(g),indeterminateKeys:Array.from(A)}}function w(e,t,n,i){const{treeNodeMap:s,getChildren:u}=t,r=new Set,d=new Set(e);return e.forEach(f=>{const o=s.get(f);o!==void 0&&M(o,h=>{if(h.disabled)return G.STOP;const{key:c}=h;if(!r.has(c)&&(r.add(c),d.add(c),Z(h.rawNode,u))){if(i)return G.STOP;if(!n)throw new J}})}),d}function $(e,{includeGroup:t=!1,includeSelf:n=!0},i){var s;const u=i.treeNodeMap;let r=e==null?null:(s=u.get(e))!==null&&s!==void 0?s:null;const d={keyPath:[],treeNodePath:[],treeNode:r};if(r!=null&&r.ignored)return d.treeNode=null,d;for(;r;)!r.ignored&&(t||!r.isGroup)&&d.treeNodePath.push(r),r=r.parent;return d.treeNodePath.reverse(),n||d.treeNodePath.pop(),d.keyPath=d.treeNodePath.map(f=>f.key),d}function ee(e){if(e.length===0)return null;const t=e[0];return t.isGroup||t.ignored||t.disabled?t.getNext():t}function te(e,t){const n=e.siblings,i=n.length,{index:s}=e;return t?n[(s+1)%i]:s===n.length-1?null:n[s+1]}function _(e,t,{loop:n=!1,includeDisabled:i=!1}={}){const s=t==="prev"?ne:te,u={reverse:t==="prev"};let r=!1,d=null;function f(o){if(o!==null){if(o===e){if(!r)r=!0;else if(!e.disabled&&!e.isGroup){d=e;return}}else if((!o.disabled||i)&&!o.ignored&&!o.isGroup){d=o;return}if(o.isGroup){const h=T(o,u);h!==null?d=h:f(s(o,n))}else{const h=s(o,!1);if(h!==null)f(h);else{const c=re(o);c!=null&&c.isGroup?f(s(c,n)):n&&f(s(o,!0))}}}}return f(e),d}function ne(e,t){const n=e.siblings,i=n.length,{index:s}=e;return t?n[(s-1+i)%i]:s===0?null:n[s-1]}function re(e){return e.parent}function T(e,t={}){const{reverse:n=!1}=t,{children:i}=e;if(i){const{length:s}=i,u=n?s-1:0,r=n?-1:s,d=n?-1:1;for(let f=u;f!==r;f+=d){const o=i[f];if(!o.disabled&&!o.ignored)if(o.isGroup){const h=T(o,t);if(h!==null)return h}else return o}}return null}const ie={getChild(){return this.ignored?null:T(this)},getParent(){const{parent:e}=this;return e!=null&&e.isGroup?e.getParent():e},getNext(e={}){return _(this,"next",e)},getPrev(e={}){return _(this,"prev",e)}};function se(e,t){const n=t?new Set(t):void 0,i=[];function s(u){u.forEach(r=>{i.push(r),!(r.isLeaf||!r.children||r.ignored)&&(r.isGroup||n===void 0||n.has(r.key))&&s(r.children)})}return s(e),i}function ae(e,t){const n=e.key;for(;t;){if(t.key===n)return!0;t=t.parent}return!1}function D(e,t,n,i,s,u=null,r=0){const d=[];return e.forEach((f,o)=>{var h;const c=Object.create(i);if(c.rawNode=f,c.siblings=d,c.level=r,c.index=o,c.isFirstChild=o===0,c.isLastChild=o+1===e.length,c.parent=u,!c.ignored){const v=s(f);Array.isArray(v)&&(c.children=D(v,t,n,i,s,c,r+1))}d.push(c),t.set(c.key,c),n.has(r)||n.set(r,[]),(h=n.get(r))===null||h===void 0||h.push(c)}),d}function le(e,t={}){var n;const i=new Map,s=new Map,{getDisabled:u=W,getIgnored:r=q,getIsGroup:d=H,getKey:f=U}=t,o=(n=t.getChildren)!==null&&n!==void 0?n:j,h=t.ignoreEmptyChildren?a=>{const l=o(a);return Array.isArray(l)?l.length?l:null:l}:o,c=Object.assign({get key(){return f(this.rawNode)},get disabled(){return u(this.rawNode)},get isGroup(){return d(this.rawNode)},get isLeaf(){return R(this.rawNode,h)},get shallowLoaded(){return V(this.rawNode,h)},get ignored(){return r(this.rawNode)},contains(a){return ae(this,a)}},ie),v=D(e,i,s,c,h);function N(a){if(a==null)return null;const l=i.get(a);return l&&!l.isGroup&&!l.ignored?l:null}function g(a){if(a==null)return null;const l=i.get(a);return l&&!l.ignored?l:null}function A(a,l){const p=g(a);return p?p.getPrev(l):null}function C(a,l){const p=g(a);return p?p.getNext(l):null}function b(a){const l=g(a);return l?l.getParent():null}function L(a){const l=g(a);return l?l.getChild():null}const S={treeNodes:v,treeNodeMap:i,levelTreeNodeMap:s,maxLevel:Math.max(...s.keys()),getChildren:h,getFlattenedNodes(a){return se(v,a)},getNode:N,getPrev:A,getNext:C,getParent:b,getChild:L,getFirstAvailableNode(){return ee(v)},getPath(a,l={}){return $(a,l,S)},getCheckedKeys(a,l={}){const{cascade:p=!0,leafOnly:K=!1,checkStrategy:k="all",allowNotLoaded:m=!1}=l;return E({checkedKeys:P(a),indeterminateKeys:x(a),cascade:p,leafOnly:K,checkStrategy:k,allowNotLoaded:m},S)},check(a,l,p={}){const{cascade:K=!0,leafOnly:k=!1,checkStrategy:m="all",allowNotLoaded:y=!1}=p;return E({checkedKeys:P(l),indeterminateKeys:x(l),keysToCheck:a==null?[]:I(a),cascade:K,leafOnly:k,checkStrategy:m,allowNotLoaded:y},S)},uncheck(a,l,p={}){const{cascade:K=!0,leafOnly:k=!1,checkStrategy:m="all",allowNotLoaded:y=!1}=p;return E({checkedKeys:P(l),indeterminateKeys:x(l),keysToUncheck:a==null?[]:I(a),cascade:K,leafOnly:k,checkStrategy:m,allowNotLoaded:y},S)},getNonLeafKeys(a={}){return F(v,a)}};return S}export{le as c};
